# simbox

Personal test for AI-generated code, and simulator for 2D array-based simulations.

All visualization code (`vis.c/h`) was generated by Claude Sonnet 4, and refined further by me.

## Usage

Run `make` to generate binary, then `./ant` to begin execution.

## Extensibility

All interaction with the simulation is handled through `Behavior`s:
```c
struct Behavior {
    int (*condition)(State*, int);
    void (*execution)(State*, int);
};
```
The `condition` function determines whether the rule should be executed, and the `execution` function mutates the state to execute the behavior.

Behaviors can be registered via `add_rules`. See `register_langton(...)` for an example.
```c
void add_rules(State *st, Behavior...)
```
Note that behaviors are executed sequentially, and the modified state is passed from one behavior to the next. This can cause issues if the behavior expects the state of the simulation before any rules have been executed on it (i.e. the rules for Langton's ant if they were split).

A possible alternative to provide the base state to each behavior after a simulation tick would be to return a resultant vector from every `execution`, and then sum these vectors to move 'all at once'.